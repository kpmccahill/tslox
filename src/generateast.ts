/** 
 * Programatically generate the AST for the language.
 * 
 * If this was java I'd put this under a separate tools package.
 */
import * as fs from 'fs';

// Entry
export function main(args: string[]) {
    if (args.length !== 1) {
        console.error("Usage: npm run generateast <output directory>")
        process.exit(64)
    }
    var outputDir: string = args[0]
    defineAst(outputDir, "Expr", [
        "Binary ; left: Expr, operator: Token, right: Expr",
        "Grouping ; expression: Expr",
        "Literal ; value: any | undefined", // in the book this is Object, but I'm doing any | undefinded since it's equivalent ( all java items are objects in the end)
        "Unary ; operator: Token, right: Expr",
    ]);
}

/**
 * Writes the file to the specified file based on outputDir + baseName.
 * 
 * NOTE: In contrast to the book implementation, I will have to build the file and THEN write.
 * versus building while the writer is open.
 * 
 * 
 * @param outputDir string - the dir to place the file in
 * @param baseName string - the name of the file itself
 * @param types string[] - the types to be generated.
 */
function defineAst(outputDir: string, baseName: string, types: Array<string>): void {
    var path: string = outputDir + "/" + baseName.toLowerCase() + ".ts"
    var source: string = "// Autogenerated code\n";
    source += "import { Token } from './token'\n";
    source += "\n"
    source += `export abstract class ${baseName} { }\n\n`

    for (var type in types) {
        let className: string = types[type].split(";")[0].trim();
        let fields: string = types[type].split(";")[1].trim();
        source += defineType(baseName, className, fields);
        // console.log(`${className}: ${fields}`)
    }

    fs.writeFileSync(path, source)
}


/**
 * 
 * @param baseName base class name to extend
 * @param className name of the type to generate a class for
 * @param fieldList the list of fields that type requires
 * @returns a class definition for the type
 */
function defineType(baseName: string, className: string, fieldList: string): string {
    let source: string = `export class ${className} extends ${baseName} {\n`
    source += buildTypeFields(fieldList) + "\n"
    source += buildTypeConstructor(fieldList)
    source += "}\n\n"
    
    return source
}

/**
 * 
 * @param fieldList a list of fields to generate
 * @returns fields for the class
 */
function buildTypeFields(fieldList: string): string {
    let fields = fieldList.split(",")
    let source = ""
    for (var field in fields) {
        source += `    ${fields[field].trim()};\n`
    }
    return source;
}

/**
 * 
 * @param fieldList string of fields to assign in the constructor.
 * @returns a constructor
 */
function buildTypeConstructor(fieldList: string): string {
    let fields = fieldList.split(",")

    let source = ""
    source += `    constructor (${fieldList.trim()}) {\n`
    source += `        super()\n`
    const pad = "        "
    for (var field in fields) {
        var identifier = fields[field].split(":")[0]
        source += pad + `this.${identifier} = ${identifier}\n`
    }
    source += "    }\n"
    
    return source
}


main(process.argv.slice(2))