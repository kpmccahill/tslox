/** 
 * Programatically generate the AST for the language.
 * 
 * If this was java I'd put this under a separate tools package.
 */
import * as fs from 'fs';

// Entry
export function main(args: string[]) {
    if (args.length !== 1) {
        console.error("Usage: npm run generateast <output directory>")
        process.exit(64)
    }
    var outputDir: string = args[0]
    defineAst(outputDir, "Expr", [
        "Binary ; left: Expr, operator: Token, right: Expr",
        "Grouping ; expression: Expr",
        "Literal ; value: any | undefined", // in the book this is Object, but I'm doing any | undefinded since it's equivalent ( all java items are objects in the end)
        "Unary ; operator: Token, right Expr",
    ]);
}

/**
 * Writes the file to the specified file based on outputDir + baseName.
 * 
 * NOTE: In contrast to the book implementation, I will have to build the file and THEN write.
 * versus building while the writer is open.
 * 
 * 
 * @param outputDir string - the dir to place the file in
 * @param baseName string - the name of the file itself
 * @param types string[] - the types to be generated.
 */
function defineAst(outputDir: string, baseName: string, types: Array<string>): void {
    var path: string = outputDir + "/" + baseName.toLowerCase() + ".txt"
    var source: string = "// Autogenerated code\n";
    source += "import { Token } from './token'\n";
    source += "\n"
    source += `export abstract class ${baseName} { }\n\n`

    for (var type in types) {
        let className: string = types[type].split(";")[0].trim();
        let fields: string = types[type].split(";")[1].trim();
        source += defineType(baseName, className, fields);
        // console.log(`${className}: ${fields}`)
    }

    fs.writeFileSync(path, source)
}

function defineType(baseName: string, className: string, fields: string): string {
    


    let source: string = `export class ${className} extends ${baseName} {\n`
    source += buildTypeFields(fields)
    source += "}\n\n"
    
    return source
}

function buildTypeFields(fields: string) {
    let fields_array = fields.split(",")
    let source = ""
    for (var field in fields_array) {
        source += `    ${fields_array[field].trim()};\n`
    }
    return source
    // var fields_string = ""
    // for (var field in fields_split) {
    //     let field_arr = fields_split[field].trim().split(" ")
    //     for (var i = 0; i < field_arr.length; i++) {
    //         if (i === 0) {
    //             fields_string += `    ${field_arr[i]}: `
    //         } else if ( i + 1 === field_arr.length) {
    //             fields_string += `${field_arr[i]}\n`
    //         }
    //         else {
    //             fields_string += `${field_arr[i]} `
    //         }
    //     }   
    // }

    // return fields_string
}


main(process.argv.slice(2))